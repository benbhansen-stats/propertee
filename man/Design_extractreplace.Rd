% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/DesignAccessors.R
\name{treatment}
\alias{treatment}
\alias{treatment,Design-method}
\alias{treatment<-}
\alias{treatment<-,Design-method}
\alias{units_of_assignment}
\alias{units_of_assignment,Design-method}
\alias{units_of_assignment<-}
\alias{units_of_assignment<-,Design-method}
\alias{clusters}
\alias{clusters,Design-method}
\alias{clusters<-}
\alias{clusters<-,Design-method}
\alias{unitids}
\alias{unitids,Design-method}
\alias{unitids<-}
\alias{unitids<-,Design-method}
\alias{blocks}
\alias{blocks,Design-method}
\alias{blocks<-}
\alias{blocks<-,Design-method}
\alias{has_blocks}
\alias{forcings}
\alias{forcings,Design-method}
\alias{forcings<-}
\alias{forcings<-,Design-method}
\title{Accessors and Replacers for \code{Design} objects}
\usage{
treatment(x, binary = FALSE, newdata = NULL, by = NULL, ...)

\S4method{treatment}{Design}(x, binary = FALSE, newdata = NULL, by = NULL, ...)

treatment(x) <- value

\S4method{treatment}{Design}(x) <- value

units_of_assignment(x, newdata = NULL, by = NULL)

\S4method{units_of_assignment}{Design}(x, newdata = NULL, by = NULL)

units_of_assignment(x) <- value

\S4method{units_of_assignment}{Design}(x) <- value

clusters(x, newdata = NULL, by = NULL)

\S4method{clusters}{Design}(x, newdata = NULL, by = NULL)

clusters(x) <- value

\S4method{clusters}{Design}(x) <- value

unitids(x)

\S4method{unitids}{Design}(x)

unitids(x) <- value

\S4method{unitids}{Design}(x) <- value

blocks(x, newdata = NULL, by = NULL)

\S4method{blocks}{Design}(x, newdata = NULL, by = NULL)

blocks(x) <- value

\S4method{blocks}{Design}(x) <- value

has_blocks(x)

forcings(x, newdata = NULL, by = NULL)

\S4method{forcings}{Design}(x, newdata = NULL, by = NULL)

forcings(x) <- value

\S4method{forcings}{Design}(x) <- value
}
\arguments{
\item{x}{a \code{Design} object}

\item{binary}{Controls whether a \code{dichotomy} is applied before
returning the treatment variable. See \code{Details}.}

\item{newdata}{optional; an additional \code{data.frame}. If passed, and the
unit of assignment variable is found in \code{newdata}, then the requested
variable type for each unit of \code{newdata} is returned. See \code{by}
argument if the name of the unit of assignment differs.}

\item{by}{optional; named vector or list connecting names of unit of
assignment/unitid/cluster variables in \code{x} to unit of
assignment/unitid/cluster variables in \code{data}. Names represent
variables in \code{x}; values represent variables in \code{newdata}. Only
needed if variable names differ.}

\item{...}{ignored.}

\item{value}{replacement. Either a \code{vector}/\code{matrix} of
appropriate dimension, or a named \code{data.frame} if renaming variable
as well. See \code{Details}.}
}
\value{
\code{data.frame} containing requested variable, or an updated
\code{Design}. \code{\link[=treatment]{treatment()}} works slightly differently, see
\code{Details}.
}
\description{
Allows access to the elements which define a \code{Design},
enabling their extraction or replacement.
}
\details{
For \code{\link[=treatment]{treatment()}}, when argument \code{binary} is \code{FALSE}, the
treatment variable passed into the \code{Design} is returned as a
one-column \code{data.frame} regardless of whether it is binary or
\code{x} has a \code{dichotomy}

If \code{binary = TRUE} is passed, and the \code{Design} either has a
binary treatment variable, or has a \code{dichotomy}, a binary one-column
\code{data.frame} will be returned. If the \code{Design} does not have
access to binary treatment (non-binary treatment and no \code{dichotomy}
specified), passing \code{binary = TRUE} will error.

\code{binary = "ifany"} is the most permissible; returning the
dichotomized treatment variable if \code{@dichotomy} exists, otherwise
returning the original treatment without error.

The one-column \code{data.frame} returned by \code{\link[=treatment]{treatment()}} is named as
entered in the \code{Design} creation, but if a \code{dichotomy} is in the
\code{Design}, the column name is \code{"__z"} to try and avoid any name
conflicts.

For the \code{value} when using replacers, the replacement must have the
same number of rows as the \code{Design} (the same number of units of
assignment). The number of columns can differ (e.g. if the \code{Design}
were defined with two variable uniquely identifying blocks, you can
replace that with a single variable uniquely identifying blocks, as long
as it respects other restrictions.)

If the replacement value is a \code{data.frame}, the name of the columns
is used as the new variable names. If the replacement is a \code{matrix}
or \code{vector}, the original names are retained. If reducing the number
of variables (e.g., moving from two variables uniquely identifying to a
single variable), the appropriate number of variable names are retained.
If increasing the number of variables, a \code{data.frame} with names must
be provided.
}
\examples{
data(simdata)
des <- obs_design(z ~ unit_of_assignment(cid1, cid2), data = simdata)
blocks(des) # empty
blocks(des) <- data.frame(blks = c(1, 1, 2, 2, 3, 3, 4, 4, 5, 5))
blocks(des)
blocks(des) <- c(5, 5, 4, 4, 3, 3, 2, 2, 1, 1)
blocks(des) # notice that variable is not renamed
}
