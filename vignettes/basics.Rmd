---
title: "Basics"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{basics}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(flexida)
```

```{r}
data(simdata)
head(simdata)
```

`simdata` is some fake data with 50 observations in 10 clusters spread over two
variables (`cid1`, `cid2`), nexted within three blocks (`bid`), an optional
forcing variable (`force`), with treatment (`z`), outcome (`y`) and predictor
(`x`). `force` and `z` are constant within cluster.

```{r}
des <- RD_Design(z ~ cluster(cid1, cid2) + block(bid) + forcing(force), data = simdata)
des
summary(des)
```

The `cluster`, `block`, and `forcing` functions are currently very simple (and
functionally identical). I considered moving `survival`'s `strata` over in its
entirety but a lot of its code seemed unneccessary for our work. There can be
only a single treatment variable, but each of `cluster`, `block`, and `forcing`
support any number of variables.

The `*_Design` functions (`RD_Design`, `RCT_Design`, `Obs_Design`) create an
object of class `Design`. Since `Design` is S4, I built a validity checker
(`setValidity`) that gets run automatically whenever a new `Design` object is
created, and can be manually run by calling `validObject(des)`. It checks for
things such as non-binary or constant treatment, disagreement on row numbers,
and invalid types. Most of these errors should never hit, but its protection if
we muck around in the internals.

`Design` objects contain three slots:

```{r}
des@structure
des@columnIndex
des@type
```

The `@columnIndex` flags each column of the table for their type; the treatment
will always be the first column, but subsequent columns depend on the order of
the formula. The formula cannot contain multiple elements, e.g. `cluster(cid1) +
cluster(cid2)` will error.

Extractors and replacers work for the cluster information table

```{r}
treatment(des)
clusters(des)
blocks(des)
forcings(des)
treatment(des) <- rep(0:1, times = 5)
treatment(des)
treatment(des) <- data.frame(q = rep(1:0, times = 5))
treatment(des)
```

Note that the replacers handle renaming of these variables appropriately.

Weights can be generated using the `ett` and `ate` functions directly.

```{r}
wdes <-ate(des, data = simdata)
wdes
slotNames(wdes)
```

`WeightedDesign` is an S4 object that contains a numeric vector of weights, and
has slots for a `Design` object and a `target`, which is one of either "ett" or
"ate". Arithmetic operations are supported on `WeightedDesign` but it disallows
addition/subtraction or multiplication by negatives.

```{r, error = TRUE}
wdes * 3
1/wdes
wdes^2
wdes + 3
wdes * -2
```

There is basic support for including `WeightedDesign` in `lm` models.

```{r}
mod <- lm(y ~ x, data = simdata, weights = wdes)
class(mod$weights)
class(mod$model$"(weights)")
```

Note the disconnect between the two sources of weights that Ben identified. The
current implementation is very fragile; it relies on `data <- get("data", envir
= sys.frame(-4))` which I suspect will break at the first time someone glances
at it wrong.

The more robust way to carry out the model is with the `ittestimate` command.

```{r}
ittest <- ittestimate(des, simdata, outcome = "y", target = "ett")
ittest
```

`ittestimate` produces a `DirectAdjusted` S4 object which contains the `lm`, and
has slots for the original `Design` as well as a `target`, one of "ett" or
"ate".

Additional arguments to `ittestimate` include:

- `covAdjModel`, a model which is passed into the `cov_adj` function.
- `clusterIds`, a list which allows renaming of cluster IDs in the current data.

```{r}
cmod <- lm(y ~ x, data = simdata)
names(simdata)[1:2] <- c("clust1", "clust2")
ittest <- ittestimate(des, simdata, outcome = "y", target = "ett",
                      covAdjModel = cmod,
                      clusterIds = list("cid1" = "clust1",
                                        "cid2" = "clust2"))
ittest
```

Note that the `Design` object that `DirectAdjusted` carries around has the
*updated* cluster IDs, so `identical(des, ittestimate@Design` will be false.
