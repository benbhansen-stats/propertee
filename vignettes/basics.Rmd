---
title: "Basics"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Basics}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Summary

The `flexida` package consists of three primary S4 classes:

- `Design`: Stores design-level information including a cluster information table
    - Created via `RCT_Design`, `RD_Design`, or `Obs_Design`.
    - Has extractors and replacers, e.g. `cluster(des)` or `cluster(des) <- ...`
- `WeightedDesign`: Contains a vector of weights, and has the original `Design`
  in a slot. Weights are at the level of the data, not necessarily at cluster
  level.
    - Three ways to create:
        1. Directly e.g. `ate(des, mydata)`.
        2. Using the `ittestimate` function which takes in a `Design` and data
           and runs a `lm` to estimate difference in means of outcome by
           treatment status.
        3. Passing as the `weights` argument to `lm`; `lm(..., weights =
           ate(des))`. (This method is fragile at the moment.)
    - Supports appropriate arithmetic (e.g. disallows `ate(des)*-2`).
    - Current weight calculations are placeholders.
- `DirectAdjusted`: Created by either `ittestimate` or by converting an `lm`
  with `WeightedDesign` weights via `as.DirectAdjusted`. Contains the `lm` and
  the `Design` in a slot.
    - Basic framework for `vcov.DirectAdjusted`, etc, but needs expansion.

The `ittestimate` function also supports a covariance adjustment model (which is
passed to the `cov_adj` function) and a list passed as `clusterIds` to allow
renaming of cluster ID variables in a different data.

## Detail

```{r setup}
library(flexida)
```

```{r}
data(simdata)
head(simdata)
```

`simdata` is some fake data with 50 observations in 10 clusters spread over two
variables (`cid1`, `cid2`), nested within three blocks (`bid`), an optional
forcing variable (`force`), with three potential treatment variables (`z`,
binary; `o`, ordinal; `dose`, continuous), outcome (`y`) and predictor (`x`).
`force` and all treatment variables are constant within cluster.

```{r}
des <- RD_Design(z ~ cluster(cid1, cid2) + block(bid) + forcing(force), data = simdata)
des
summary(des)
```

The `cluster`, `block`, and `forcing` functions are currently very simple (and
functionally identical). I considered moving `survival`'s `strata` over in its
entirety but a lot of its code seemed unnecessary for our work. There can be
only a single treatment variable, but each of `cluster`, `block`, and `forcing`
support any number of variables.

The `*_Design` functions (`RD_Design`, `RCT_Design`, `Obs_Design`) create an
object of class `Design`. Since `Design` is S4, I built a validity checker
(`setValidity`) that gets run automatically whenever a new `Design` object is
created, and can be manually run by calling `validObject(des)`. It checks for
things such as constant or otherwise problematic treatment, disagreement on row
numbers, and invalid types. Most of these errors should never hit, but its
protection if we muck around in the internals.

`Design` objects contain five slots:

```{r}
des@structure
des@columnIndex
des@type
des@call
des@clustertype
```

The `@columnIndex` flags each column of the table for their type; the treatment
will always be the first column, but subsequent columns depend on the order of
the formula. The formula cannot contain multiple elements, e.g. `cluster(cid1) +
cluster(cid2)` will error.

The `@clustertype` flags whether the Design was created with a `cluster()` or a
`unitid()`; internally we always refer to this element as the "cluster", but can
use the `@clustertype` to affect logic (e.g. to change output).

Extractors and replacers work for the cluster information table

```{r}
treatment(des)
clusters(des)
blocks(des)
forcings(des)
treatment(des) <- as.factor(rep(0:1, times = 5))
treatment(des)
treatment(des) <- data.frame(q = as.factor(rep(1:0, times = 5)))
treatment(des)
```

Note that the replacers handle renaming of these variables appropriately.

```{r}
# Renaming treatment back
treatment(des) <- data.frame(z = as.factor(rep(1:0, times = 5)))
```

Weights can be generated using the `ett` and `ate` functions directly.

```{r}
wdes <-ate(des, data = simdata)
wdes
slotNames(wdes)
```

`WeightedDesign` is an S4 object that contains a numeric vector of weights, and
has slots for a `Design` object and a `target`, which is one of either "ett" or
"ate". Arithmetic operations are supported on `WeightedDesign` but it disallows
addition/subtraction or multiplication by negatives.

```{r, error = TRUE}
wdes * 3
1/wdes
wdes^2
wdes + 3
wdes * -2
```

There is basic support for including `WeightedDesign` in `lm` models.

```{r}
mod <- lm(y ~ x, data = simdata, weights = wdes)
mod
class(mod$weights)
class(mod$model$"(weights)")
mod
mod <- lm(y ~ x, data = simdata, weights = ate(des))
class(mod$weights)
class(mod$model$"(weights)")
```

Note the disconnect between the two sources of weights that Ben identified. The
current implementation is very fragile; it relies on `data <- get("data", envir
= sys.frame(-4))` which I suspect will break at the first time someone glances
at it wrong.

The more robust way to carry out the model is with the `ittestimate` command.

```{r}
ittest <- ittestimate(des, simdata, outcome = "y", target = "ett")
ittest
```

`ittestimate` produces a `DirectAdjusted` S4 object which contains the `lm`, and
has slots for the original `Design` as well as a `target`, one of "ett" or
"ate".

Additional arguments to `ittestimate` include:

- `covAdjModel`, a model which is passed into the `cov_adj` function.
- `clusterIds`, a list which allows renaming of cluster IDs in the current data.

```{r}
cmod <- lm(y ~ x, data = simdata)
names(simdata)[1:2] <- c("clust1", "clust2")
ittest <- ittestimate(des, simdata, outcome = "y", target = "ett",
                      covAdjModel = cmod,
                      clusterIds = list("cid1" = "clust1",
                                        "cid2" = "clust2"))
ittest
```

Note that the `Design` object that `DirectAdjusted` carries around has the
*updated* cluster IDs, so `identical(des, ittestimate@Design)` will be false.
