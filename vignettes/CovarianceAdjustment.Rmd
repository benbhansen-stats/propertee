---
title: "Covariance Adjustment for Randomized Trials"
author: "Mark Fredrickson"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Covariance Adjustment for Randomized Trials}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(tidyverse)
```

```{r}
library(flexida)
```

## Data and Design

The data come from the state of Tennessee's Student-Teacher Achievement Ratio (STAR) experiment. Students were randomly assigned to three possible classroom conditions: small (13 to 17 students per teacher), regular class (22 to 25 students per teacher), and regular-with-aide class (22 to 25 students with a full-time teacher's aide). The `AER` package for R provides the data set, also available elsewhere on the internet.

```{r, results = 'hide', message = FALSE, error = FALSE, warning = FALSE}
library(AER)
data(STAR)
```

Student compliance was not constant over years:
```{r}
with(STAR, table(stark, star1), useNA = "always")
with(STAR, table(star2, star3), useNA = "always")
```
Taking that kindergarten treatment as the intended treatment, we proceed with an intent-to-treat analysis, ignoring actual classroom attendance in grades 1 to 3. Additionally, we collapse the `regular` and `regular+aide` categories into a single category to compare the effect of small classrooms against regular classrooms, including those with teacher's aides.
```{r}
STAR$treatment <- STAR$stark == "small"
STAR$treatment[is.na(STAR$treatment)] <- FALSE
table(STAR$treatment)
```


To illustrate the workflow of a researcher in the midst of a trial, we split the data into two data sets, one representing student information that might have been known prior or during assignment and a second representing outcome information only available after the intervention had been administered.

```{r}
STAR$studentid <- as.character(1:nrow(STAR))
STAR_pre <- STAR[, c("studentid", "treatment",
                     "gender", "ethnicity", "birth", "lunchk",  # individual demographics
                     "schoolk", "degreek", "ladderk", "experiencek", "tethnicityk", # school and teacher demographics
                     "systemk", "schoolidk" # school ID information
                     )]
```

As students were blocked into schools, and then randomized within school, we establish the design based on those stratifications. Including a set of weights that we will use later.
```{r}
STAR_school <- group_by(STAR_pre, schoolidk) %>%
  summarize(school_n = n(), school_n1 = sum(treatment), school_n0 = school_n - school_n1)
STAR_pre <- left_join(STAR_pre, STAR_school, by = "schoolidk") %>%
  mutate(E_Z         = school_n1 / school_n,
         weight_ate  = treatment / E_Z + (1 - treatment) / (1 - E_Z),
         weight_ett  = treatment + (1 - treatment) * E_Z / (1 - E_Z),
         weight_etc  = treatment * (1 - E_Z) / E_Z + (1 - treatment))
```

Post-treatment outcomes include normalized reading and math scores over several years. Missing values are imputed to the within group (treatment/control) mean
```{r}

STAR_post <- rbind(
  data.frame(studentid = STAR$studentid, year = "k", read = STAR$readk, math = STAR$mathk, strings.as.factors = FALSE),
  data.frame(studentid = STAR$studentid, year = "1", read = STAR$read1, math = STAR$math1, strings.as.factors = FALSE),
  data.frame(studentid = STAR$studentid, year = "2", read = STAR$read2, math = STAR$math2, strings.as.factors = FALSE),
  data.frame(studentid = STAR$studentid, year = "3", read = STAR$read3, math = STAR$math3, strings.as.factors = FALSE))

## imputation to within group means
STAR_pre_post <- inner_join(STAR_pre, STAR_post, by = "studentid")

```

While students were grouped within classrooms with the same teacher, the assignment to classroom type was performed at the individual level within schools.


```{r}
## STAR_design <- RCT_Design(treatment ~ cluster(studentid) + strata(schoolidk), data = STAR_pre)
STAR_design <- RCT_Design(treatment ~ cluster(studentid), data = STAR_pre)
```
We are interested in the treatment effects for the the different ethnicities composing the study population.

```{r}
ggplot(STAR_pre_post, aes(x = read, group = treatment)) + geom_boxplot() + facet_wrap(~ ethnicity)
```

## Covariance Model

```{r}

rhs <- ~ gender + ethnicity + birth + lunchk +
  ladderk + experiencek + tethnicityk + year

covariance_y0_read <- lm(update(rhs, read ~ .), data = STAR_pre_post, subset = !treatment)
covariance_y0_math <- lm(update(rhs, math ~ .), data = STAR_pre_post, subset = !treatment)

## of !! is to turn numeric into logical
covariance_y1_read <- lm(update(rhs, read ~ .), data = STAR_pre_post, subset = !!treatment)
covariance_y1_math <- lm(update(rhs, math ~ .), data = STAR_pre_post, subset = !!treatment)
```

## Outcome Analysis

Let $y_1$ and $y_0$ be the potential outcomes, let $Z$ be a binary treatment indicator, and posit that the Stable Unit Treatment Value assumption holds such that $Y = Z y_1 - (1 - Z) y_0$. For a finite population of $n$ units, define the *average treament effect* as
$$\Delta = \frac{1}{n} \sum_{i=1}^n y_{i1} - y_{i0}.$$

Suppose we have a model $y_{i0} = g(x_i ; \beta_0)$. After fitting parameters $\hat \beta_0$, let $\hat y_{i0} = g(x_i ; \hat \beta_0)$. Adding and subtracting the estimated potential outcomes does not changing the average treatment effect:

$$\Delta = \frac{1}{n} \sum_{i=1}^n y_{i1} - y_{i0} + \hat y_{i0} - \hat y_{i0} = \frac{1}{n} \sum_{i=1}^n (y_{i1} - \hat y_{i0})  - \frac{1}{n} \sum_{i=1}^n (y_{i0} - \hat y_{i0}).$$

Additionally, for any binary treatment vector $Z$, we can decompose the average treatment effect as the effect on the treated group (i.e., $Z = 1$) and the effect on the control group (i.e., $Z = 0$):
\[
\begin{aligned}
\Delta &= \frac{1}{n} \sum_{i=1}^n Z_i\left[(y_{i1} - \hat y_{i0})  - (y_{i0} - \hat y_{i0})\right] + \\
 & \quad  \frac{1}{n} \sum_{i=1}^n (1 - Z_i) \left[(y_{i1} - \hat y_{i0})  - (y_{i0} - \hat y_{i0})\right]  \\
 &= \frac{n_1}{n} \delta(Z) + \frac{n_0}{n} \delta(1 - Z),
\end{aligned}
\]
where $n_1 = \sum_{i=1}^n Z_i$ and $n_0 = \sum_{i=1}^n 1 - Z_i$. As $Z$ represents a random vector, taking expectation yields the expected treatment effect for the treated units
\[
\begin{aligned}
\delta_1 &= E(\delta(Z)) =  \frac{1}{n_1} \sum_{i=1}^n E(Z_i) \left[(y_{i1} - \hat y_{i0}) - (y_{i0} - \hat y_{i0})\right]\\
&= \frac{1}{n} \sum_{i=1}^n \left[\frac{n}{n_1} E(Z_i)\right] (y_{i1} - \hat y_{i0}) - \frac{1}{n} \sum_{i=1}^n \left[\frac{n}{n_1} E(Z_i)\right] (y_{i10} - \hat y_{i0}) ,
\end{aligned}
\]
and the expected treatment effect for the control units $\delta_0 = E(\delta(1 - Z))$, analogously.


To estimate $\Delta$, $\delta_1$, and $\delta_0$,  we introduce a difference of Hajek estimators,
\[
d(w) =\frac{\sum_{i=1} w_i Z_i (Y_i - \hat y_{i0})}{\sum_{i=1}^n w_i Z_i} -
\frac{\sum_{i=1} w_i (1 - Z_i) (Y_i - \hat y_{i0})}{\sum_{i=1}^n w_i (1 - Z_i)}.
\]

- For $\Delta$: $w_i = Z_i/E(Z_i) + (1 - Z)/E(1 - Z_i)$. In the case of completely randomized designs, $E(Z_i) = n_1/n$, $E(1 - Z_i) = n_0/n$, and the estimator reduces to the well known difference of means estimator.
- For $\delta_1$: $w_i = Z_i + (1 - Z_i) E(Z_i) / E(1 - Z_i)$.
- For $\delta_0$: $w_i = Z_i E(1 - Z_i) / E(Z_i) + (1 - Z_i)$.

The weights may also include case weights or be multiplied by subgroup indicators to estimate subgroup specific effects.

To demonstrate this function, we implement the estimator directly and also show how it can be estimated using our suite of tools.

```{r}
dw <- function(w, z, y, y0_hat) {
  tmp <- data.frame(w, z, y, y0_hat) %>% na.omit
  with(tmp,
    sum(w * z * (y - y0_hat)) / sum(w * z) -
      sum(w * (1 - z) * (y - y0_hat)) / sum(w * (1 - z))
  )
}
```

We begin with using the various covariance models to impute the missing potential outcomes and individual treatment effects.

```{r}
STAR_pre_post_k <- filter(STAR_pre_post, year == "k")

pred <- function(mod) {
  predict(mod, newdata = STAR_pre_post_k, type = "response")
}

STAR_pre_post_k <-
    mutate(STAR_pre_post_k,
         read_y0_hat = pred(covariance_y0_read),
         read_y1_hat = pred(covariance_y1_read),
         math_y0_hat = pred(covariance_y0_math),
         math_y1_hat = pred(covariance_y1_math))
```

### Effect of Treatment on the Treated

#### Reading Scores

For each of the treatment effects, we compute the point estimates using both the `lm` function and direct calculation.
```{r}
## overall treatment effects on the treated
ett_read_lm <- lm(read ~ treatment,
                  data = STAR_pre_post_k,
                  weights = weight_ett,
                  offset = read_y0_hat)
coef(ett_read_lm)[2]

with(STAR_pre_post_k, dw(weight_ett, treatment, read, read_y0_hat))

## ETT within subgroups
ett_read_ethnicity_lm <- lm(read ~ treatment * ethnicity,
                               data = STAR_pre_post_k,
                               weights = weight_ett,
                               offset = read_y0_hat)

data.frame(eth = levels(STAR_pre_post_k$ethnicity),
           ett = coef(ett_read_ethnicity_lm)[2] + c(cauc = 0, coef(ett_read_ethnicity_lm)[8:12]))

STAR_pre_post_k %>%
    group_by(ethnicity) %>%
    summarize(dw(weight_ett, treatment, read, read_y0_hat))
```
The following is not currently implemented, but represents expected interface.
```{r, eval = FALSE}
STAR_ett    <- ett(STAR_design)
## notice the formula does not mention the blocking factor
ett_read_lm <- lm(read ~ treatment, offset = cov_adj(covariance_y0_read), weights = STAR_ett)
```

### Average Treatment Effects

#### Reading Scores

```{r}
## overall ATE
ate_read_lm <- lm(read ~ treatment,
                  data = STAR_pre_post_k,
                  weights = weight_ate,
                  offset = read_y0_hat)
coef(ate_read_lm)[2]

with(STAR_pre_post_k, dw(weight_ate, treatment, read, read_y0_hat))

ate_read_ethnicity_lm <- lm(read ~ treatment * ethnicity,
                            data = STAR_pre_post_k,
                            weights = weight_ate,
                            offset = read_y0_hat)

data.frame(eth = levels(STAR_pre_post_k$ethnicity),
           ate = coef(ate_read_ethnicity_lm)[2] + c(cauc = 0, coef(ate_read_ethnicity_lm)[8:12]))

STAR_pre_post_k %>%
    group_by(ethnicity) %>%
    summarize(dw(weight_ate, treatment, read, read_y0_hat))
```


The following is not currently implemented, but represents expected interface.
```{r, eval = FALSE}
STAR_ate    <- ate(STAR_design)
## notice the formula does not mention the blocking factor
ate_read_lm <- lm(read ~ treatment, offset=cov_adj(covariance_y0_read),
                  data = filter(STAR_post, year = "k"), weights = STAR_ate)
```
