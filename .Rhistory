vcovDA(damod_abs_off, type = "DB_CR0")
devtools::load_all()
vcovDA(damod_abs, type = "DB_CR0")
vcovDA(damod_abs_off, type = "DB_CR0")
vcovDA(damod_abs, type = "DB_CR0")
devtools::load_all()
vcovDA(damod_abs, type = "DB_CR0")
vcovDA(damod_abs_off, type = "DB_CR0")
sandwich::meatCL()
sandwich::meatCL
devtools::load_all()
vcovDA(damod_abs, type = "DB_CR0")
vcovDA(damod_abs_off, type = "DB_CR0")
sandwich::meatCL(damod_abs)
sandwich::meatCL(damod_abs_off)
sandwich::meatCL(damod)
damod <- lmitt(y ~ 1, design = des, data = simdata, weights = ate(des))
damod_off <- lmitt(y ~ 1, design = des, data = simdata, weights = ate(des),
offset = cov_adj(cmod))
vcovDA(damod)
vcovDA(damod_off)
vcovDA(damod_abs_off)
vcovDA(damod_abs)
sandwich::meatCL(damod_abs)
devtools::load_all()
vcovDA(damod_abs, type = "DB_CR0")
sandwich::meatCL(damod_abs, db=TRUE)
sandwich::meatCL(damod_abs_off, db=TRUE)
sandwich::meatCL(damod_abs_off)
sandwich::meatCL(damod_abs, db=TRUE)
sandwich::meatCL(damod_abs)
hel(sandwich::meatCL)
help(sandwich::meatCL)
help("sandwich::meatCL")
sandwich::meatCL
is.list(damod) && !is.null(damod$na.action)
is.list(damod_abs_off) && !is.null(damod_abs_off$na.action)
is.list(damod_abs) && !is.null(damod_abs$na.action)
sandwich::meatCL(damod_abs_off)
sandwich::meatCL(damod_abs)
sandwich::meatCL(damod_abs_off, db=TRUE)
sandwich::meatCL(damod_abs, db=TRUE)
estfun.DirectAdjusted(damod_abs, db=TRUE)
estfun.DirectAdjusted(damod_abs)
estfun.DirectAdjusted(damod_abs_off, db=TRUE)
devtools::load_all()
estfun.DirectAdjusted(damod_abs_off, db=TRUE)
estfun.DirectAdjusted(damod_abs, db=TRUE)
estfun.DirectAdjusted(damod_abs, db=TRUE)
devtools::load_all()
estfun.DirectAdjusted(damod_abs, db=TRUE)
devtools::load_all()
estfun.DirectAdjusted(damod_abs, db=TRUE)
estfun.DirectAdjusted(damod_abs)
estfun.DirectAdjusted(damod_abs_off, db=TRUE)
ate(des, data=simdata)
damod$weights
ate(damod@Design, data=damod$call$data)
devtools::load_all()
vcovDA(damod)
vcovDA(damod_abs)
devtools::load_all()
vcovDA(damod)
devtools::load_all()
vcovDA(damod)
vcovDA(damod_abs)
vcovDA(damod_off)
vcovDA(damod_abs_off)
vcovDA(damod_off, type = "DB_CR0")
vcovDA(damod_abs, type = "DB_CR0")
vcovDA(damod_abs_off, type = "DB_CR0")
devtools::load_all()
vcovDA(damod_abs, type = "DB_CR0")
vcovDA(damod_abs_off, type = "DB_CR0")
devtools::load_all()
vcovDA(damod_abs_off, type = "DB_CR0")
vcovDA(damod_abs, type = "DB_CR0")
devtools::test()
devtools::test()
damod$call
damod$call$formula
damod$call$weights@.Data
damod$call$weights@target
damod$call$weights@Design
damod$call$weights@Design@call
damod$call$weights@Design@unit_of_assignment_type
damod$model$flexida_y - simdata$y
damod_abs$model$flexida_y - simdata$y
damod_abs_off$model$flexida_y - simdata$y
damod_abs_off$fitted.values
damod_abs$fitted.values
damod_abs$fitted.values + damod_abs$residuals == damod_abs$model$flexida_y
damod_abs$effects
damod_abs$terms
damod_abs$terms[[1]]
damod_abs@lmitt_fitted
damod_abs$assign
damod_abs$df.residual
mean(simdata$y)
mean(simdata[simdata$z == 0, ]$y)
lmitt(y ~ 1 + dose, design = des, data = simdata)
lmitt(y ~ dose, design = des, data = simdata)
lmitt(y ~ 1, design = des, data = simdata)
lmitt(y ~ 1, design = des, data = simdata, weights = ate(des))
lmitt(y ~ dose, design = des, data = simdata, weights = ate(des))
damod_sbgp <- lmitt(y ~ dose, design = des, data = simdata, weights = ate(des))
vcovDA(damod_sbgp)
vcovDA(damod_sbgp, type = "DB_CR0")
damod_sbgp <- lmitt(y ~ dose, design = des, data = simdata, weights = ate(des), absorb = TRUE)
vcovDA(damod_sbgp)
vcovDA(damod_sbgp, type = "DB_CR0")
damod_sbgp$coefficients
damod_sbgp@Design
damod_sbgp@Design@type
damod_sbgp@Design@structure
colnames(simdaya)
colnames(simdata)
colnames(simdata)[9]
colnames(simdata)[9] <- "Outcome"
cmod <- lm(outcome ~ x, simdata)
cmod <- lm(Outcome ~ x, simdata)
damod <- lmitt(Outcome ~ 1, design = des, data = simdata, weights = ate(des))
vcovDA(damod)
damod_abs <- lmitt(Outcome ~ 1, design = des, data = simdata, weights = ate(des),
absorb = TRUE)
vcovDA(damod_abs)
vcovDA(damod_abs, type = "DB_CR0")
damod_abs$call$data$y
damod_abs$call$data$Outcome
damod_abs$call$data$flexida_y
damod_abs$call$formula
.center(mr, lm.call$weights, logicalsubset)
damod_abs.call
stats::model.response(damod)
stats::model.response(damod_abs)
cmod$y
cmod <- lm(y ~ x, simdata)
reponse(cmod)
stats::model.reponse(cmod)
cmod$model$Outcome
model.frame(cmod)
formula(cmod)
formula(cmod)[1]
formula(cmod)[0]
formula(cmod)[[1]]
formula(damod)
formula(damod_abs)
response(damod)
model.frame(damod)
devtools::load_all()
vcovDA(damod_abs, type = "DB_CR0")
vcovDA(damod_abs)
vcovDA(damod_abs_off, type = "DB_CR0")
devtools::load_all()
vcovDA(damod_abs, type = "DB_CR0")
vcovDA(damod_abs_off, type = "DB_CR0")
devtools::load_all()
vcovDA(damod_abs, type = "DB_CR0")
vcovDA(damod_abs_off, type = "DB_CR0")
devtools::load_all()
vcovDA(damod_abs, type = "DB_CR0")
vcovDA(damod_abs_off, type = "DB_CR0")
model.extract(lm)
model.extract(cmod)
model.response(cmod)
model.offset(damod)
model.offset(damod_off)
model.frame(damod)
lmitt.formula(damod)
lmitt.formula(damod, damod@Design, damod$call$data)
lmitt.formula(damod, damod@Design, damod$call$data, weights = ate(damod@Design))
lmitt.formula(damod$call, damod@Design, damod$call$data, weights = ate(damod@Design))
lmitt.formula(y~1, damod@Design, damod$call$data, weights = ate(damod@Design))
data(simdata)
lmitt.formula(y~1, damod@Design, damod$call$data, weights = ate(damod@Design))
View(simdata)
damod <- lmitt(y ~ 1, design = des, data = simdata, weights = ate(des))
lmitt.formula(y~1, damod@Design, damod$call$data, weights = ate(damod@Design))
lmitt(y ~ 1, design = des, data = simdata, weights = ate(des))
test.formula <- function(obj,
design,
data,
absorb = FALSE,
offset = NULL,
weights = NULL,
...) {
lmitt.call <- match.call()
m <- match(c("obj", "data", "subset", "weights", "na.action",
"method", "model", "x", "y", "qr", "singular.ok",
"contrasts", "offset"), names(lmitt.call), 0L)
lm.call <- lmitt.call[c(1L, m)]
names(lm.call)[2] <- "formula"
lm.call[[1]] <- quote(stats::lm)
print(lmitt.call)
return(0)
}
test.formula <- function(obj,
design,
data,
absorb = FALSE,
offset = NULL,
weights = NULL,
...) {
lmitt.call <- match.call()
m <- match(c("obj", "data", "subset", "weights", "na.action",
"method", "model", "x", "y", "qr", "singular.ok",
"contrasts", "offset"), names(lmitt.call), 0L)
lm.call <- lmitt.call[c(1L, m)]
names(lm.call)[2] <- "formula"
lm.call[[1]] <- quote(stats::lm)
print(lmitt.call)
print(m)
return(0)
}
test.formula(y~1, des, simdata, weights = ate(des))
test.formula <- function(obj,
design,
data,
absorb = FALSE,
offset = NULL,
weights = NULL,
...) {
lmitt.call <- match.call()
m <- match(c("obj", "data", "subset", "weights", "na.action",
"method", "model", "x", "y", "qr", "singular.ok",
"contrasts", "offset"), names(lmitt.call), 0L)
lm.call <- lmitt.call[c(1L, m)]
names(lm.call)[2] <- "formula"
lm.call[[1]] <- quote(stats::lm)
print(lmitt.call)
print(m)
print(lm.call)
return(0)
}
test.formula(y~1, des, simdata, weights = ate(des))
test.formula <- function(obj,
design,
data,
absorb = FALSE,
offset = NULL,
weights = NULL,
...) {
lmitt.call <- match.call()
m <- match(c("obj", "data", "subset", "weights", "na.action",
"method", "model", "x", "y", "qr", "singular.ok",
"contrasts", "offset"), names(lmitt.call), 0L)
lm.call <- lmitt.call[c(1L, m)]
names(lm.call)[2] <- "formula"
lm.call[[1]] <- quote(stats::lm)
print(lmitt.call)
print(m)
print(lm.call[[1]])
return(0)
}
test.formula(y~1, des, simdata, weights = ate(des))
coef(damod)
respond(damod)
response(damod)
residuals(damod)
residuals(damod) == damod$residuals
fitted.values(damod) == damod$fitted.values
print(flexida_y)
test.formula <- function(obj,
design,
data,
absorb = FALSE,
offset = NULL,
weights = NULL,
...) {
lmitt.call <- match.call()
m <- match(c("obj", "data", "subset", "weights", "na.action",
"method", "model", "x", "y", "qr", "singular.ok",
"contrasts", "offset"), names(lmitt.call), 0L)
lm.call <- lmitt.call[c(1L, m)]
names(lm.call)[2] <- "formula"
lm.call[[1]] <- quote(stats::lm)
# Save the subset and remove it from `lm.call`, to be re-added at the enc
savedsubset <- lm.call$subset
logicalsubset <- eval(savedsubset, data)
lm.call$subset <- NULL
### Allow users to pass in "ate" and "ett" rather than functions if they have
### no special modifications/additional arguments
wt <- lmitt.call$weights
if (is(wt, "character")) {
if (tolower(wt) == "ate") {
lm.call$weights <- quote(ate())
lmitt.call$weights <- quote(ate())
} else if (tolower(wt) == "ett") {
lm.call$weights <- quote(ett())
lmitt.call$weights <- quote(ett())
} else {
warning(paste("Character other than \"ate\" or \"ett\" passed to",
"`weights=` argument.\nIf you are trying to pass a",
"character to the internal `lm` you can disregard this",
"warning.\nIf you are attemping to use `flexida`\'s",
"weight generation, only \"ate\" and \"ett\" are",
"accepted."))
}
}
# First, make sure we have a valid `design=` - if given a formula, make a new
# `Design`, otherwise ensure `design=` is `Design` class.
if (inherits(design, "formula")) {
# If there's a `forcing()`, user wants RDD. If not, force Obs. To do RCT,
# must create Design manually.
if (!is.null(attr(terms(design, specials = "forcing"),
"specials")$forcing)) {
des_call <- "rd_design"
} else {
des_call <- "obs_design"
}
# Build new call. All calls must include obj and data
new_d_call <- paste0(des_call, "(",
"formula = ", deparse(design),
", data = ", deparse(lmitt.call$data))
# If user passed dichotomy, include it. We do this so the
# `design@call` will be in agreement.
if (!is.null(lmitt.call$dichotomy)) {
new_d_call <- paste0(new_d_call, ", dichotomy = ",
deparse(lmitt.call$dichotomy))
}
new_d_call <- paste0(new_d_call, ")")
# str2lang converts character into call
design <- eval(str2lang(new_d_call))
} else if (is(design, "WeightedDesign")) {
design <- design@Design
} else if (!is(design, "Design")) {
stop(paste("`design=` must be an object created by `*_design`",
"function, or a formula specifying such a design"))
}
# Extract formula bits
rhs <- trimws(strsplit(deparse(obj[[3]]), "+", fixed = TRUE)[[1]])
rhs <- rhs[rhs != "+"]
if (length(rhs) > 1) {
# At max two terms ("sbgrp" and "1")
stop(paste("Too many terms on right hand side. To estimate subgroup",
"effects and main effect simultaneously, fit two",
"separate models."))
}
if (rhs == "0") {
# We don't support y ~ 0
stop("'0' is not a valid entry on right hand side")
}
.check_for_assigned_and_aliases <- function(fn) {
if (grepl(paste0(fn, "\\("), rhs)) {
stop(paste("Do not specify `assigned()` or any of it's aliases in",
"the right hand side of `lmitt()`.\nTo estimate only",
"a treatment effect, pass `~ 1` as the right hand side."))
}
}
.check_for_assigned_and_aliases("assigned")
.check_for_assigned_and_aliases("adopters")
.check_for_assigned_and_aliases("a\\.")
.check_for_assigned_and_aliases("z\\.")
# `rhs` is now either "1" or subgrouping variable
# Get weights and offset if passed
lm.call$weights <- eval.parent(lm.call$weights)
lm.call$offset <- eval.parent(lm.call$offset)
if (!is(lm.call$weights, "WeightedDesign") & !absorb) {
if ("b" %in% design@column_index) {
if (options()$flexida_message_on_unused_blocks) {
message(paste("The Design object contains block-level information,",
"but it is not used in this model. Block information",
"is used when weights are defined via `ate()` or `ett()`",
"or if the `absorb=TRUE` argument is passed."))
}
}
}
# Ensure same design is used in weights and offset, if they're there
wtdes <- try(lm.call$weights@Design, silent = TRUE)
ofdes <- try(lm.call$offset@Design, silent = TRUE)
if (is(wtdes, "Design")) {
if (!identical(design, wtdes)) {
stop(paste("Multiple differing `Design` found (`design` argument to",
" `lmitt` and `design` object inside the weights differ)."))
}
}
if (is(ofdes, "Design")) {
if (!identical(design, ofdes)) {
stop(paste("Multiple differing `Design` found (`design` argument to",
" `lmitt` and `design` object inside the offset differ)."))
}
}
# Evaluate model.frame
mf.call <- lm.call
mf.call[[1]] <- quote(stats::model.frame)
# Add assigned() to the model so it utilizes Design characteristics (primarly
# concerned about subset)
mf.call[[2]] <- stats::update(eval(mf.call[[2]]), . ~ . + flexida::assigned())
mf.call$na.action <- "na.pass"
mf <- eval(mf.call, parent.frame())
areg.center <- function(var, grp, wts = NULL) {
if (!is.null(wts)) {
# weighted.mean produces NA if any weights are NA
if (any(is.na(wts))) {
var2 <- var[!is.na(wts)]
} else {
var2 <- var
}
df <- data.frame(var = var, wts = wts)
var - sapply(split(df, grp), function(x) {
stats::weighted.mean(x$var, x$wts, na.rm = TRUE)
})[as.character(grp)] +
stats::weighted.mean(var2, w = wts[!is.na(wts)], na.rm = TRUE)
} else {
var - tapply(var, grp, mean, na.rm = TRUE)[as.character(grp)] +
mean(var, na.rm = TRUE)
}
}
if (absorb) {
if (length(var_names(design, "b")) == 0) {
stop("No blocks found in Design, cannot absorb")
}
blocks <- .get_col_from_new_data(design,
eval(lm.call$data, parent.frame()),
"b", all.x = TRUE)[, 1]
# To be used below
}
if (rhs == "1") {
# Define new RHS and obtain model.matrix
new.form <- formula(~ flexida::assigned()) # need flexida:: or assigned()
# can't be found
#    environment(new.form) <- saveenv # Do I need this?
mm.call <- lm.call
mm.call[[2]] <- str2lang(deparse(new.form))
# model.matrix.lm supports as `na.action` argument where
# model.matrix.default doesn't
mm.call[[1]] <- quote(stats::model.matrix.lm)
mm.call$na.action <- "na.pass"
names(mm.call)[2] <- "object"
mm <- eval(mm.call, parent.frame())
if (absorb) {
mm <- apply(mm, 2, areg.center, as.factor(blocks), lm.call$weights)
}
absorbed_moderators <- character()
} else {
# Create model.matrix with subgroup main effects (to BE residualized out)
sbgrp.form <- stats::reformulate(paste0(paste(rhs,
"flexida::assigned()",
sep = "+"),
"+ 0"))
sbgrp.call <- lm.call
sbgrp.call[[2]] <- str2lang(deparse(sbgrp.form))
sbgrp.call[[1]] <- quote(stats::model.matrix.lm)
names(sbgrp.call)[2] <- "object"
sbgrp.call$na.action <- "na.pass"
sbgrp.mm <- eval(sbgrp.call, parent.frame())
sbgrp.mm <- sbgrp.mm[, !grepl("assigned\\(", colnames(sbgrp.mm)),
drop = FALSE]
# Create model.matrix with treatment:subgroup interaction (to be kept in)
effect.form <- stats::reformulate(paste0("flexida::assigned():", rhs, "+0"))
effect.call <- lm.call
effect.call[[2]] <- str2lang(deparse(effect.form))
effect.call[[1]] <- quote(stats::model.matrix.lm)
effect.call$na.action <- "na.pass"
names(effect.call)[2] <- "object"
effect.mm <- eval(effect.call, parent.frame())
if (absorb) {
sbgrp.mm <- apply(sbgrp.mm, 2, areg.center, as.factor(blocks),
lm.call$weights)
effect.mm <- apply(effect.mm, 2, areg.center, as.factor(blocks),
lm.call$weights)
}
# Using `__xx__` to try and ensure no collision with variable names
mm <- apply(effect.mm, 2, function(xx__) {
resid.call <- lm.call
resid.call$offset <- NULL #see issue #101
resid.call$formula <- stats::reformulate("sbgrp.mm", "xx__")
# By switching from `na.omit` to `na.exclude`, `residuals()` includes NAs
resid.call$na.action <- "na.exclude"
stats::residuals(eval(resid.call, parent.frame()))
})
absorbed_moderators <- rhs
}
# Strip intercept from model
mm <- mm[, !grepl("(Intercept)", colnames(mm)), drop = FALSE]
# Make sure to keep it as a named matrix
# Center (weighted if needed)
.center <- function(x, wts, sbst) {
# If the user passed in `$subset`, we'll want to center by the mean of the
# subset, not the whole data.
if (!is.null(sbst)) {
xs <- x[sbst]
} else {
xs <- x
}
# `weighted.mean` with a NULL weights argument calls `mean`, but due to
# the below issue with NAs in the weights, don't try combining these two
# calls into one.
if (is.null(wts)) {
x - mean(xs, na.rm = TRUE)
} else {
# `weighted.mean` with `na.rm = TRUE` only drops `x` as NA, any NA weights
# will return an NA mean
x - weighted.mean(xs[!is.na(lm.call$weights)],
lm.call$weights[!is.na(lm.call$weights)],
na.rm = TRUE)
}
}
# Center variables to remove intercept
mm <- apply(mm, 2, .center, lm.call$weights, logicalsubset)
# get response
mr <- stats::model.response(mf)
if (is.matrix(mr)) {
# if somehow user passes in a matrix outcome, handle centering appropriately
flexida_y <- apply(mr, 2, .center, lm.call$weights, logicalsubset)
} else {
flexida_y <- .center(mr, lm.call$weights, logicalsubset)
}
print(flexida_y)
return(0)
}
test.formula(y~1, des, simdata, weights = ate(des))
