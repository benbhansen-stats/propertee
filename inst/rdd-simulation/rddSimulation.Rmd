---
title: "Polynomial Simulation like in LRD paper"
author: "Adam C Sales & Ben B Hansen"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,error=FALSE,message=FALSE,warning=FALSE)
knitr::opts_knit$set(root.dir = '.')
```

General dependencies.
```{r}
library('knitr')
require('kableExtra')
library('rdrobust')
#library(flexida)
source('simulationFunctions.r')
source('ddsandwich.R') ###
source('displaySim.r')
```

```{r}
pkgload::load_all("../..")
```


## Overview

### Manipulated factors

- $n$=50,500,2500
- $Y_C$ regression f'n='lin','antiSym','wass'
- error dist $\mathcal{N}(0,1)$, $t_3$
- treatment effect $\tau$=0.5, $\mathcal{N}(0.5,1)$, $\tau | R \sim \mathcal{N}(0.5|R|,1)$

### Analysis models

- OLS, deg=1, ... ,5
- RD-robust
- flexpoly w/lmrob deg=1,...,5
- flexpoly w/ median regression deg=1,...5

### Questions

- "unadjusted std errors?"
- point estimate for `rdrobust`
- `cov_adj` for quantile regression
- CIs? 

## Running Simulation 



Initialization. Note that `nreps=0` corresponds to no simulations,
just print results from previously saved simulations.
In order to re-run the simulations, the `nreps`
variable should have been set to a positive integer before initiating this script.

To run the simulations in parallel, using the `parallel` package in
`R`,
register a cluster, called `cl` with the desired number of nodes, with
code similar to the following:
```{r eval=FALSE,echo=TRUE}
library(parallel)
cl <- makeCluster(5)
```

```{r  runLoadOutSim, warning=FALSE, message=FALSE}
if (!exists('nreps') ) nreps <- 0
nreps
if (nreps) {
library('robustbase')
library('rdd')
library('RItools')
library('sandwich')
library('nnet')

clust <- FALSE
if(require('parallel')) if(exists('cl')) if(inherits(cl,"cluster")) clust <- TRUE

if(clust){
  clusterEvalQ(cl,{

    library('robustbase')
    library('rdd')
    library('RItools')
    library('sandwich')
    library('nnet')
    devtools::load_all("../..")
                                        #           library(flexida)
    source('simulationFunctions.r')
    source('ddsandwich.R') ###
    source('displaySim.r')
  })
} else cl <- NULL
}
```
## Run the simulation

```{r  runLoadPolySim, warning=FALSE, message=FALSE}
if (nreps) {
  set.seed(201609)
  st2 <- system.time(totalPoly <- totalPolySim(nreps,cl))
  save(totalPoly,file=paste0("./totalPolySim",Sys.Date(),".RData"))
  cat(paste0(date(), ', nreps=', nreps, '\n'),
      paste(c(names(st2),'\n', collapse=T)),
      st2,
      file='totalPolySim-runtime.txt', append=TRUE)
} else{
  psims <- sort(grep('totalPolySim',list.files('.'),value=TRUE),decreasing=TRUE)

  load(paste0('./',psims[1]))
}
```

The following gives the results in Table 4 of the paper, in addition
to the break-down of RMSE into bias and variance, and analogous
results for normally-distributed errors.

```{r, eval=FALSE}
tab <- prntTab(totalPoly,5,full=TRUE,md=FALSE)
#rownames(tab) <- rep(c('level','RMSE','bias','sd'),6)
colnames(tab) <- gsub('(flex|ols)\\.se.','deg=',colnames(tab))#c(rep(paste0('deg=',1:4),2),'')
colnames(tab)[ncol(tab)] <- 'n/a'
kable(tab,format='html',caption='Full results for polynomial simulation',digits=2)%>%
    kable_styling()%>% column_spec( 6,border_right=TRUE)%>%column_spec(11,border_right=TRUE)%>%
        add_header_above(c(" " = 1, "flexida" = 5, "OLS" = 5, "Loc. Lin." = 1))%>%
            #group_rows("$t_3$ Error",1,12)%>%group_rows("N(0,1) Error",13,24)%>%
            group_rows("linear",1,5)%>%group_rows('antiSym',6,10)%>%group_rows('sine',11,15)#%>%
                #group_rows("linear",13,16)%>%group_rows('antiSym',17,20)%>%group_rows('oneSide',21,24)
```


Session information
```{r}
sessionInfo()
```
